{% extends "base.html" %}

{% block title %}{{ market.question[:50] }} - Morning Markets{% endblock %}

{% block extra_head %}
<script>
// WebSocket-powered real-time updates with HTMX polling fallback
(function() {
    // Market ID from URL
    const marketId = '{{ market.id }}';

    // Debug mode - set to true in console to enable timing logs
    // Usage: window.enableDebugTiming(true) or set localStorage.setItem('debugTiming', 'true')
    let debugTimingEnabled = localStorage.getItem('debugTiming') === 'true';

    // Enable/disable debug timing from console
    window.enableDebugTiming = function(enabled) {
        debugTimingEnabled = enabled;
        localStorage.setItem('debugTiming', enabled ? 'true' : 'false');
        console.log('Debug timing ' + (enabled ? 'enabled' : 'disabled'));
    };

    // Log timing information (only if debug mode enabled)
    function logTiming(operation, startTime, details) {
        if (!debugTimingEnabled) return;
        const elapsed = performance.now() - startTime;
        console.log('[TIMING] ' + operation + ': ' + elapsed.toFixed(1) + 'ms', details || '');
    }

    // WebSocket state
    let ws = null;
    let reconnectAttempts = 0;
    const MAX_RECONNECT_DELAY = 60000; // 60 seconds max
    const INITIAL_RECONNECT_DELAY = 1000; // 1 second
    let reconnectTimeout = null;
    let usingWebSocket = false;

    // Position tracking for trade feedback
    let previousPosition = null;
    let audioContext = null;
    let soundEnabled = false;

    // ============ Aggress Submission (Vanilla JS) ============
    // Uses fetch() instead of HTMX for more reliable aggress form submission
    // This avoids complex HTMX event chain issues with dynamically added forms
    let aggressInProgress = false;
    let pendingOrderbookUpdate = null;

    function applyOrderbookUpdate(newOrderbook) {
        const orderbookTarget = document.getElementById('orderbook');
        if (orderbookTarget && newOrderbook) {
            orderbookTarget.innerHTML = newOrderbook.innerHTML;
            // Attach click handlers to new aggress buttons
            attachAggressHandlers();
        }
    }

    // Execute aggress trade via fetch() - bypasses HTMX entirely
    async function executeAggress(orderId, button) {
        const qty = getClickSize();
        const fak = getFillAndKill();

        console.log('[AGGRESS] Executing via fetch:', { orderId, qty, fak });

        // Disable button and show spinner
        button.disabled = true;
        const btnText = button.querySelector('.btn-text');
        const btnSpinner = button.querySelector('.btn-spinner');
        if (btnText) btnText.style.display = 'none';
        if (btnSpinner) btnSpinner.style.display = 'inline-block';

        // Block WebSocket updates during submission
        aggressInProgress = true;
        pendingOrderbookUpdate = null;

        const startTime = performance.now();

        try {
            const formData = new FormData();
            formData.append('quantity', qty.toString());
            formData.append('fill_and_kill', fak ? 'true' : 'false');

            const response = await fetch('/orders/' + orderId + '/aggress', {
                method: 'POST',
                body: formData,
                headers: {
                    'HX-Request': 'true'  // Mimic HTMX request for proper response
                },
                credentials: 'same-origin'  // Include cookies
            });

            logTiming('Aggress fetch', startTime, 'orderId=' + orderId);

            // Read response headers for toast messages
            const successMsg = response.headers.get('HX-Toast-Success');
            const errorMsg = response.headers.get('HX-Toast-Error');

            if (successMsg) {
                showToast(successMsg, false);
                console.log('[AGGRESS] Success:', successMsg);
            } else if (errorMsg) {
                showToast(errorMsg, true);
                console.log('[AGGRESS] Error:', errorMsg);
            } else if (!response.ok) {
                // HTTP error without custom header
                const text = await response.text();
                showToast('Trade failed: ' + (text || response.statusText), true);
                console.log('[AGGRESS] HTTP error:', response.status, text);
            }

        } catch (error) {
            console.error('[AGGRESS] Fetch error:', error);
            showToast('Network error - please try again', true);
        } finally {
            // Re-enable button
            button.disabled = false;
            if (btnText) btnText.style.display = '';
            if (btnSpinner) btnSpinner.style.display = '';

            // Release lock and apply pending update
            aggressInProgress = false;
            console.log('[AGGRESS] Lock released');
            if (pendingOrderbookUpdate) {
                console.log('[AGGRESS] Applying pending orderbook update');
                applyOrderbookUpdate(pendingOrderbookUpdate);
                pendingOrderbookUpdate = null;
            }
        }
    }

    // Attach click handlers to aggress buttons (called on init and after DOM updates)
    function attachAggressHandlers() {
        const orderbook = document.getElementById('orderbook');
        if (!orderbook) return;

        // Find all aggress buttons by their class (ladder-buy-btn or ladder-sell-btn)
        const buttons = orderbook.querySelectorAll('.ladder-buy-btn, .ladder-sell-btn');

        buttons.forEach(function(button) {
            // Skip if already has handler attached
            if (button.dataset.aggressHandlerAttached) return;
            button.dataset.aggressHandlerAttached = 'true';

            // Find the form and extract order ID from action URL
            const form = button.closest('form');
            if (!form) return;

            const action = form.getAttribute('hx-post');
            if (!action) return;

            // Extract order ID from URL like /orders/{id}/aggress
            const match = action.match(/\/orders\/([^\/]+)\/aggress/);
            if (!match) return;

            const orderId = match[1];

            // Prevent HTMX from handling this form
            form.removeAttribute('hx-post');
            form.removeAttribute('hx-swap');

            // Add click handler
            button.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                executeAggress(orderId, button);
            });

            console.log('[AGGRESS] Handler attached for order:', orderId);
        });
    }

    // ============ Toast Notifications ============
    function showToast(message, isError) {
        const container = document.getElementById('toast-container');
        if (!container) return;

        const toast = document.createElement('div');
        toast.className = 'toast ' + (isError ? 'toast-error' : 'toast-success');
        toast.textContent = message;
        container.appendChild(toast);

        // Remove after animation completes
        setTimeout(function() {
            toast.remove();
        }, 3000);
    }

    // ============ Connection Status Indicator ============
    function updateConnectionStatus(state) {
        const statusDiv = document.getElementById('connection-status');
        if (!statusDiv) return;

        const dot = statusDiv.querySelector('.connection-dot');
        const text = statusDiv.querySelector('.connection-text');

        dot.classList.remove('connected', 'reconnecting', 'disconnected');

        if (state === 'connected') {
            dot.classList.add('connected');
            text.textContent = 'Live';
        } else if (state === 'reconnecting') {
            dot.classList.add('reconnecting');
            text.textContent = 'Reconnecting...';
        } else if (state === 'polling') {
            dot.classList.add('connected');
            text.textContent = 'Polling';
        } else {
            dot.classList.add('disconnected');
            text.textContent = 'Disconnected';
        }
    }

    // ============ Audio Feedback ============
    function initAudio() {
        if (audioContext) return;
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            soundEnabled = true;
        } catch (e) {
            console.log('Web Audio not supported');
        }
    }

    function playBeep(isBuy) {
        if (!audioContext || !soundEnabled) return;

        try {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Higher pitch for buy, lower for sell
            oscillator.frequency.value = isBuy ? 880 : 440;
            oscillator.type = 'sine';

            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.15);
        } catch (e) {
            console.log('Audio error:', e);
        }
    }

    // ============ Position Flash Animation ============
    function flashPosition(isBuy) {
        const positionBox = document.getElementById('position-content');
        if (!positionBox) return;

        positionBox.classList.remove('flash-buy', 'flash-sell');
        void positionBox.offsetWidth; // Force reflow to restart animation
        positionBox.classList.add(isBuy ? 'flash-buy' : 'flash-sell');
    }

    function checkPositionChange() {
        const positionContent = document.getElementById('position-content');
        if (!positionContent) return;

        const newPosition = parseInt(positionContent.dataset.position || '0', 10);

        // Skip the first load (no previous value to compare)
        if (previousPosition === null) {
            previousPosition = newPosition;
            return;
        }

        // Detect if position changed (trade happened)
        if (newPosition !== previousPosition) {
            const isBuy = newPosition > previousPosition;
            playBeep(isBuy);
            flashPosition(isBuy);
        }

        previousPosition = newPosition;
    }

    // ============ DOM Updates ============
    function updateFromWebSocket(html) {
        console.log('[WS DEBUG] updateFromWebSocket called, aggressInProgress:', aggressInProgress);
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');

        // Update position content
        const newPositionContent = doc.getElementById('position-content');
        if (newPositionContent) {
            const positionTarget = document.getElementById('position-content');
            if (positionTarget) {
                positionTarget.innerHTML = newPositionContent.innerHTML;
                for (const attr of newPositionContent.attributes) {
                    positionTarget.setAttribute(attr.name, attr.value);
                }
            }
        }

        // Update orderbook (OOB swap) - but defer if aggress is in progress
        const newOrderbook = doc.getElementById('orderbook');
        if (newOrderbook) {
            if (aggressInProgress) {
                // Store update to apply after aggress completes
                console.log('[AGGRESS] Deferring orderbook update (submission in progress)');
                pendingOrderbookUpdate = newOrderbook;
            } else {
                applyOrderbookUpdate(newOrderbook);
            }
        }

        // Update trades (OOB swap)
        const newTrades = doc.getElementById('trades');
        if (newTrades) {
            const tradesTarget = document.getElementById('trades');
            if (tradesTarget) {
                tradesTarget.innerHTML = newTrades.innerHTML;
            }
        }

        checkPositionChange();
    }

    // ============ HTMX Polling Fallback ============
    function getReconnectDelay() {
        const delay = INITIAL_RECONNECT_DELAY * Math.pow(2, reconnectAttempts);
        return Math.min(delay, MAX_RECONNECT_DELAY);
    }

    function disablePolling() {
        const positionDiv = document.getElementById('position');
        if (positionDiv) {
            positionDiv.removeAttribute('hx-trigger');
            positionDiv.removeAttribute('hx-get');
            if (typeof htmx !== 'undefined') {
                htmx.process(positionDiv);
            }
        }
    }

    function enablePolling() {
        const positionDiv = document.getElementById('position');
        if (positionDiv) {
            positionDiv.setAttribute('hx-trigger', 'every 500ms');
            positionDiv.setAttribute('hx-get', '/partials/market/' + marketId);
            positionDiv.setAttribute('hx-swap', 'innerHTML');
            positionDiv.setAttribute('hx-target', '#position-content');
            if (typeof htmx !== 'undefined') {
                htmx.process(positionDiv);
            }
        }
        updateConnectionStatus('polling');
    }

    // ============ WebSocket Connection ============
    function connectWebSocket() {
        if (ws && ws.readyState === WebSocket.OPEN) {
            return;
        }

        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = protocol + '//' + window.location.host + '/ws/market/' + marketId;

        try {
            ws = new WebSocket(wsUrl);

            ws.onopen = function() {
                console.log('WebSocket connected');
                reconnectAttempts = 0;
                usingWebSocket = true;
                disablePolling();
                updateConnectionStatus('connected');
            };

            ws.onmessage = function(event) {
                const receiveTime = performance.now();
                const data = event.data;

                // Handle ping from server
                if (data === '{"type": "ping"}') {
                    ws.send('{"type": "pong"}');
                    return;
                }

                // Handle JSON messages (redirect, etc.)
                if (data.startsWith('{')) {
                    try {
                        const msg = JSON.parse(data);
                        if (msg.type === 'redirect' && msg.url) {
                            window.location.href = msg.url;
                            return;
                        }
                    } catch (e) {
                        // Not valid JSON, continue to check if it's HTML
                    }
                }

                // Handle HTML update
                if (data.includes('<div') || data.includes('<p')) {
                    const updateStart = performance.now();
                    updateFromWebSocket(data);
                    logTiming('WebSocket DOM update', updateStart, 'dataLength=' + data.length);
                }
            };

            ws.onclose = function(event) {
                console.log('WebSocket closed:', event.code, event.reason);
                usingWebSocket = false;

                // Don't reconnect if closed cleanly by server (e.g., market settled)
                if (event.code === 1000) {
                    updateConnectionStatus('disconnected');
                    return;
                }

                updateConnectionStatus('reconnecting');
                scheduleReconnect();
            };

            ws.onerror = function(error) {
                console.log('WebSocket error:', error);
            };
        } catch (e) {
            console.log('WebSocket connection failed:', e);
            usingWebSocket = false;
            enablePolling();
        }
    }

    function scheduleReconnect() {
        if (reconnectTimeout) {
            clearTimeout(reconnectTimeout);
        }

        const delay = getReconnectDelay();
        console.log('Reconnecting in ' + (delay / 1000) + 's...');
        reconnectAttempts++;

        if (!usingWebSocket) {
            enablePolling();
        }

        reconnectTimeout = setTimeout(function() {
            connectWebSocket();
        }, delay);
    }

    // ============ HTMX Event Handlers ============
    // Handle HTMX responses for non-aggress form submissions (order form, cancel)
    // NOTE: Aggress forms are handled by vanilla JS executeAggress() instead
    // NOTE: These must be attached after DOM is ready since script is in <head>
    const htmxRequestTimes = new Map();

    function setupHTMXEventHandlers() {
        document.body.addEventListener('htmx:beforeRequest', function(event) {
            // Record start time for timing measurement
            htmxRequestTimes.set(event.detail.elt, performance.now());

            // Disable submit button during request
            const button = event.detail.elt.querySelector('button[type="submit"]');
            if (button) {
                button.disabled = true;
            }
        });

        document.body.addEventListener('htmx:afterRequest', function(event) {
            // Re-enable submit button
            const button = event.detail.elt.querySelector('button[type="submit"]');
            if (button) {
                button.disabled = false;
            }

            // Log round-trip timing
            const startTime = htmxRequestTimes.get(event.detail.elt);
            if (startTime) {
                htmxRequestTimes.delete(event.detail.elt);
                const xhr = event.detail.xhr;
                const serverTime = xhr ? xhr.getResponseHeader('X-Process-Time-Ms') : null;
                logTiming('HTMX round-trip', startTime,
                    'path=' + (event.detail.pathInfo ? event.detail.pathInfo.requestPath : 'unknown') +
                    (serverTime ? ', server=' + serverTime + 'ms' : ''));
            }

            // Check for custom headers with toast messages
            const xhr = event.detail.xhr;
            if (!xhr) {
                return;
            }

            const successMsg = xhr.getResponseHeader('HX-Toast-Success');
            const errorMsg = xhr.getResponseHeader('HX-Toast-Error');

            if (successMsg) {
                showToast(successMsg, false);
                // Clear the form on success (for order form)
                if (event.detail.elt.id === 'order-form') {
                    document.getElementById('price-input').value = '';
                    document.getElementById('quantity-input').value = '';
                }
            } else if (errorMsg) {
                showToast(errorMsg, true);
                // Keep form values on error so user can fix and retry
            }
        });

        // Handle position changes from HTMX polling (fallback mode)
        // Also re-attach aggress handlers after any DOM swap
        document.body.addEventListener('htmx:afterSwap', function(event) {
            // Check for position changes
            if (event.detail.target && event.detail.target.id === 'position-content') {
                checkPositionChange();
            }

            // Re-attach aggress handlers after any swap that might affect orderbook
            // This is crucial for fallback polling mode when WebSocket is unavailable
            // The orderbook is updated via hx-swap-oob, so the target might be position-content
            // but the orderbook also gets updated in the same response
            attachAggressHandlers();
        });
    }

    // ============ Click Size Persistence ============
    function initClickSize() {
        const clickSizeInput = document.getElementById('click-size-input');
        if (!clickSizeInput) return;

        // Load from localStorage
        const savedSize = localStorage.getItem('clickSize');
        if (savedSize && !isNaN(parseInt(savedSize, 10))) {
            clickSizeInput.value = savedSize;
        }

        // Save on change
        clickSizeInput.addEventListener('change', function() {
            const val = parseInt(this.value, 10);
            if (val && val > 0) {
                localStorage.setItem('clickSize', val.toString());
            }
        });
    }

    // Get current click size
    function getClickSize() {
        const input = document.getElementById('click-size-input');
        if (input) {
            const val = parseInt(input.value, 10);
            if (val && val > 0) return val;
        }
        return 1;
    }

    // Expose getClickSize for inline use
    window.getClickSize = getClickSize;

    // ============ Fill-and-Kill Toggle Persistence ============
    function initFillAndKill() {
        const toggle = document.getElementById('fill-and-kill-toggle');
        if (!toggle) return;

        // Load from localStorage
        const savedValue = localStorage.getItem('fillAndKill');
        if (savedValue === 'true') {
            toggle.checked = true;
        }

        // Save on change
        toggle.addEventListener('change', function() {
            localStorage.setItem('fillAndKill', this.checked ? 'true' : 'false');
        });
    }

    // Get current fill-and-kill setting
    function getFillAndKill() {
        const toggle = document.getElementById('fill-and-kill-toggle');
        return toggle ? toggle.checked : false;
    }

    // Expose getFillAndKill for inline use
    window.getFillAndKill = getFillAndKill;

    // ============ Initialization ============
    document.addEventListener('click', initAudio, { once: true });

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            setupHTMXEventHandlers();
            connectWebSocket();
            initClickSize();
            initFillAndKill();
            attachAggressHandlers();  // Attach vanilla JS handlers to Buy/Sell buttons
        });
    } else {
        setupHTMXEventHandlers();
        connectWebSocket();
        initClickSize();
        initFillAndKill();
        attachAggressHandlers();  // Attach vanilla JS handlers to Buy/Sell buttons
    }

    window.addEventListener('beforeunload', function() {
        if (ws) {
            ws.close(1000, 'Page unload');
        }
    });
})();
</script>
{% endblock %}

{% block content %}
<!-- Toast container for notifications -->
<div id="toast-container" class="toast-container"></div>

<article>
    <header>
        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
            <h1>{{ market.question }}</h1>
            <div id="connection-status" class="connection-indicator" style="margin-top: 0.5rem;">
                <span class="connection-dot"></span>
                <span class="connection-text">Connecting...</span>
            </div>
        </div>
        {% if market.description %}
            <p>{{ market.description }}</p>
        {% endif %}
        <p>
            <span class="market-status {{ market.status.value|lower }}">{{ market.status.value }}</span>
            {% if market.status.value == 'SETTLED' %}
                | Settlement Value: <strong>{{ market.settlement_value }}</strong>
            {% endif %}
        </p>
    </header>

    {% if error %}
        <p class="error">{{ error }}</p>
    {% endif %}
    {% if success %}
        <p class="success">{{ success }}</p>
    {% endif %}

    {% if market.status.value == 'OPEN' %}
    <!-- Order Placement Form -->
    <section>
        <h3>Place Order</h3>
        <form id="order-form"
              hx-post="/markets/{{ market.id }}/orders"
              hx-swap="none"
              hx-indicator="#order-submit-btn">
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 1rem; align-items: end;">
                <label>
                    Side
                    <select name="side" required>
                        <option value="BID">BID (Buy)</option>
                        <option value="OFFER">OFFER (Sell)</option>
                    </select>
                </label>
                <label>
                    Price
                    <input type="number" name="price" id="price-input" step="0.01" min="0.01" required placeholder="100.00">
                </label>
                <label>
                    Quantity
                    <input type="number" name="quantity" id="quantity-input" min="1" max="{{ position_limit }}" required placeholder="5">
                </label>
                <button type="submit" id="order-submit-btn">
                    <span class="btn-spinner spinner"></span>
                    <span class="btn-text">Submit Order</span>
                </button>
            </div>
        </form>
        <small>Position limit: {{ position_limit }} lots. Your current position: {{ position.net_quantity if position else 0 }} lots.</small>
    </section>

    <!-- Click Trading Size & Fill-and-Kill Option -->
    <section class="click-size-section">
        <div style="display: flex; align-items: center; gap: 1.5rem; flex-wrap: wrap;">
            <label style="margin-bottom: 0; display: flex; align-items: center; gap: 0.5rem;">
                <strong>Click Size:</strong>
                <input type="number" id="click-size-input" min="1" max="{{ position_limit }}" value="1" style="width: 5rem; margin-bottom: 0;">
                <span>lots</span>
            </label>
            <label style="margin-bottom: 0; display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                <input type="checkbox" id="fill-and-kill-toggle" style="margin-bottom: 0;">
                <strong>Fill & Kill</strong>
            </label>
            <small style="color: var(--pico-muted-color);">When F&K is on, unfilled quantity won't become a resting order</small>
        </div>
    </section>

    {% if user.is_admin %}
    <!-- Admin: Settle Market Form -->
    <section style="border: 2px solid var(--pico-primary); padding: 1rem; border-radius: 0.5rem; margin-top: 1rem;">
        <h3>Admin: Settle Market</h3>
        <form method="POST" action="/admin/markets/{{ market.id }}/settle">
            <div style="display: grid; grid-template-columns: 2fr auto; gap: 1rem; align-items: end;">
                <label>
                    Settlement Value (actual answer)
                    <input type="number" name="settlement_value" step="any" required placeholder="e.g., 1002">
                </label>
                <button type="submit"
                        onclick="return confirm('Settle this market? This will close the market, cancel all open orders, and calculate final P&L. This cannot be undone.')">
                    Settle Market
                </button>
            </div>
        </form>
        <small>Settling will close the market and calculate P&L for all participants.</small>
    </section>
    {% endif %}

    {% elif market.status.value == 'CLOSED' %}
    <p><em>This market is closed. Waiting for settlement.</em></p>
    {% else %}
    <p><em>This market has been settled. <a href="/markets/{{ market.id }}/results">View Results</a></em></p>
    {% endif %}

    <!-- Current Position (HTMX polling - triggers combined update) -->
    <section>
        <h3>Your Position</h3>
        <div id="position"
             hx-get="/partials/market/{{ market.id }}"
             hx-trigger="every 500ms"
             hx-swap="innerHTML"
             hx-target="#position-content">
            <div id="position-content">
            {% include 'partials/position.html' %}
            </div>
        </div>
    </section>

    <!-- Order Book (updated via hx-swap-oob from combined endpoint) -->
    <section>
        <h3>Order Book</h3>
        <div id="orderbook">
            {% include 'partials/orderbook.html' %}
        </div>
    </section>

    <!-- Recent Trades (updated via hx-swap-oob from combined endpoint) -->
    <section>
        <h3>Recent Trades</h3>
        <div id="trades">
            {% include 'partials/trades.html' %}
        </div>
    </section>
</article>

<footer>
    <p><a href="/markets">‚Üê Back to Markets</a></p>
</footer>
{% endblock %}
